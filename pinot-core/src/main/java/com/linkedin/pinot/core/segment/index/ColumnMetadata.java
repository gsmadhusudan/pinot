/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.segment.index;

import com.linkedin.pinot.common.data.DimensionFieldSpec;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.FieldSpec.DataType;
import com.linkedin.pinot.common.data.FieldSpec.FieldType;
import com.linkedin.pinot.common.data.MetricFieldSpec;
import com.linkedin.pinot.common.data.TimeFieldSpec;
import com.linkedin.pinot.core.segment.creator.impl.V1Constants;
import java.lang.reflect.Field;
import java.util.concurrent.TimeUnit;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.commons.lang.StringEscapeUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.*;
import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Segment.SEGMENT_PADDING_CHARACTER;
import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Segment.TIME_UNIT;


public class ColumnMetadata {
  private static final Logger LOGGER = LoggerFactory.getLogger(ColumnMetadata.class);

  private final String columnName;
  private final int cardinality;
  private final int totalDocs;
  private final int totalRawDocs;
  private final int totalAggDocs;
  private final DataType dataType;
  private final int bitsPerElement;
  private final int stringColumnMaxLength;
  private final FieldType fieldType;
  private final boolean isSorted;
  private final boolean containsNulls;
  private final boolean hasDictionary;
  private final boolean hasInvertedIndex;
  private final boolean isSingleValue;
  private final int maxNumberOfMultiValues;
  private final int totalNumberOfEntries;
  private final boolean isAutoGenerated;
  private final String defaultNullValueString;
  private final TimeUnit timeUnit;
  private final char paddingCharacter;

  public static ColumnMetadata fromPropertiesConfiguration(String column, PropertiesConfiguration config) {
    Builder builder = new Builder();

    builder.setColumnName(column);
    builder.setCardinality(config.getInt(getKeyFor(column, CARDINALITY)));
    int totalDocs = config.getInt(getKeyFor(column, TOTAL_DOCS));
    builder.setTotalDocs(totalDocs);
    builder.setTotalRawDocs(config.getInt(getKeyFor(column, TOTAL_RAW_DOCS), totalDocs));
    builder.setTotalAggDocs(config.getInt(getKeyFor(column, TOTAL_AGG_DOCS), 0));
    builder.setDataType(DataType.valueOf(config.getString(getKeyFor(column, DATA_TYPE)).toUpperCase()));
    builder.setBitsPerElement(config.getInt(getKeyFor(column, BITS_PER_ELEMENT)));
    builder.setStringColumnMaxLength(config.getInt(getKeyFor(column, DICTIONARY_ELEMENT_SIZE)));
    builder.setFieldType(FieldType.valueOf(config.getString(getKeyFor(column, COLUMN_TYPE)).toUpperCase()));
    builder.setIsSorted(config.getBoolean(getKeyFor(column, IS_SORTED)));
    builder.setContainsNulls(config.getBoolean(getKeyFor(column, HAS_NULL_VALUE)));
    builder.setHasDictionary(config.getBoolean(getKeyFor(column, HAS_DICTIONARY), true));
    builder.setHasInvertedIndex(config.getBoolean(getKeyFor(column, HAS_INVERTED_INDEX)));
    builder.setSingleValue(config.getBoolean(getKeyFor(column, IS_SINGLE_VALUED)));
    builder.setMaxNumberOfMultiValues(config.getInt(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS)));
    builder.setTotalNumberOfEntries(config.getInt(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES)));
    builder.setAutoGenerated(config.getBoolean(getKeyFor(column, IS_AUTO_GENERATED), false));
    builder.setDefaultNullValueString(config.getString(getKeyFor(column, DEFAULT_NULL_VALUE), null));
    builder.setTimeUnit(TimeUnit.valueOf(config.getString(TIME_UNIT, "DAYS").toUpperCase()));
    char paddingCharacter = V1Constants.Str.LEGACY_STRING_PAD_CHAR;
    if (config.containsKey(SEGMENT_PADDING_CHARACTER)) {
      String padding = config.getString(SEGMENT_PADDING_CHARACTER);
      paddingCharacter = StringEscapeUtils.unescapeJava(padding).charAt(0);
    }
    builder.setPaddingCharacter(paddingCharacter);

    return builder.build();
  }

  public static class Builder {
    private String columnName;
    private int cardinality;
    private int totalDocs;
    private int totalRawDocs;
    private int totalAggDocs;
    private DataType dataType;
    private int bitsPerElement;
    private int stringColumnMaxLength;
    private FieldType fieldType;
    private boolean isSorted;
    private boolean containsNulls;
    private boolean hasDictionary;
    private boolean hasInvertedIndex;
    private boolean isSingleValue;
    private int maxNumberOfMultiValues;
    private int totalNumberOfEntries;
    private boolean isAutoGenerated;
    private String defaultNullValueString;
    private TimeUnit timeUnit;
    private char paddingCharacter;

    public Builder setColumnName(String columnName) {
      this.columnName = columnName;
      return this;
    }

    public Builder setCardinality(int cardinality) {
      this.cardinality = cardinality;
      return this;
    }

    public Builder setTotalDocs(int totalDocs) {
      this.totalDocs = totalDocs;
      return this;
    }

    public Builder setTotalRawDocs(int totalRawDocs) {
      this.totalRawDocs = totalRawDocs;
      return this;
    }

    public Builder setTotalAggDocs(int totalAggDocs) {
      this.totalAggDocs = totalAggDocs;
      return this;
    }

    public Builder setDataType(DataType dataType) {
      this.dataType = dataType;
      return this;
    }

    public Builder setBitsPerElement(int bitsPerElement) {
      this.bitsPerElement = bitsPerElement;
      return this;
    }

    public Builder setStringColumnMaxLength(int stringColumnMaxLength) {
      this.stringColumnMaxLength = stringColumnMaxLength;
      return this;
    }

    public Builder setFieldType(FieldType fieldType) {
      this.fieldType = fieldType;
      return this;
    }

    public Builder setIsSorted(boolean isSorted) {
      this.isSorted = isSorted;
      return this;
    }

    public Builder setContainsNulls(boolean containsNulls) {
      this.containsNulls = containsNulls;
      return this;
    }

    public Builder setHasDictionary(boolean hasDictionary) {
      this.hasDictionary = hasDictionary;
      return this;
    }

    public Builder setHasInvertedIndex(boolean hasInvertedIndex) {
      this.hasInvertedIndex = hasInvertedIndex;
      return this;
    }

    public Builder setSingleValue(boolean singleValue) {
      this.isSingleValue = singleValue;
      return this;
    }

    public Builder setMaxNumberOfMultiValues(int maxNumberOfMultiValues) {
      this.maxNumberOfMultiValues = maxNumberOfMultiValues;
      return this;
    }

    public Builder setTotalNumberOfEntries(int totalNumberOfEntries) {
      this.totalNumberOfEntries = totalNumberOfEntries;
      return this;
    }

    public Builder setAutoGenerated(boolean isAutoGenerated) {
      this.isAutoGenerated = isAutoGenerated;
      return this;
    }

    public Builder setDefaultNullValueString(String defaultNullValueString) {
      this.defaultNullValueString = defaultNullValueString;
      return this;
    }

    public Builder setTimeUnit(TimeUnit timeUnit) {
      this.timeUnit = timeUnit;
      return this;
    }

    public Builder setPaddingCharacter(char paddingCharacter) {
      this.paddingCharacter = paddingCharacter;
      return this;
    }

    public ColumnMetadata build() {
      return new ColumnMetadata(columnName, cardinality, totalDocs, totalRawDocs, totalAggDocs, dataType,
          bitsPerElement, stringColumnMaxLength, fieldType, isSorted, containsNulls, hasDictionary, hasInvertedIndex,
          isSingleValue, maxNumberOfMultiValues, totalNumberOfEntries, isAutoGenerated, defaultNullValueString,
          timeUnit, paddingCharacter);
    }
  }

  private ColumnMetadata(String columnName, int cardinality, int totalDocs, int totalRawDocs, int totalAggDocs,
      DataType dataType, int bitsPerElement, int stringColumnMaxLength, FieldType fieldType, boolean isSorted,
      boolean hasNulls, boolean hasDictionary, boolean hasInvertedIndex, boolean isSingleValue,
      int maxNumberOfMultiValues, int totalNumberOfEntries, boolean isAutoGenerated, String defaultNullValueString,
      TimeUnit timeUnit, char paddingCharacter) {
    this.columnName = columnName;
    this.cardinality = cardinality;
    this.totalDocs = totalDocs;
    this.totalRawDocs = totalRawDocs;
    this.totalAggDocs = totalAggDocs;
    this.dataType = dataType;
    this.bitsPerElement = bitsPerElement;
    this.stringColumnMaxLength = stringColumnMaxLength;
    this.fieldType = fieldType;
    this.isSorted = isSorted;
    this.containsNulls = hasNulls;
    this.hasDictionary = hasDictionary;
    this.hasInvertedIndex = hasInvertedIndex;
    this.isSingleValue = isSingleValue;
    this.maxNumberOfMultiValues = maxNumberOfMultiValues;
    this.totalNumberOfEntries = totalNumberOfEntries;
    this.isAutoGenerated = isAutoGenerated;
    this.defaultNullValueString = defaultNullValueString;
    this.timeUnit = timeUnit;
    this.paddingCharacter = paddingCharacter;
  }

  public String getColumnName() {
    return columnName;
  }

  public int getCardinality() {
    return cardinality;
  }

  public int getTotalDocs() {
    return totalDocs;
  }

  public int getTotalRawDocs() {
    return totalRawDocs;
  }

  public int getTotalAggDocs() {
    return totalAggDocs;
  }

  public DataType getDataType() {
    return dataType;
  }

  public int getBitsPerElement() {
    return bitsPerElement;
  }

  public int getStringColumnMaxLength() {
    return stringColumnMaxLength;
  }

  public FieldType getFieldType() {
    return fieldType;
  }

  public boolean isSorted() {
    return isSorted;
  }

  public boolean hasNulls() {
    return containsNulls;
  }

  public boolean hasDictionary() {
    return hasDictionary;
  }

  public boolean hasInvertedIndex() {
    return hasInvertedIndex;
  }

  public boolean isSingleValue() {
    return isSingleValue;
  }

  public int getMaxNumberOfMultiValues() {
    return maxNumberOfMultiValues;
  }

  public int getTotalNumberOfEntries() {
    return totalNumberOfEntries;
  }

  public boolean isAutoGenerated() {
    return isAutoGenerated;
  }

  public String getDefaultNullValueString() {
    return defaultNullValueString;
  }

  public TimeUnit getTimeUnit() {
    return timeUnit;
  }

  public char getPaddingCharacter() {
    return paddingCharacter;
  }

  public FieldSpec toFieldSpec() {
    switch (fieldType) {
      case DIMENSION:
        return new DimensionFieldSpec(columnName, dataType, isSingleValue);
      case METRIC:
        return new MetricFieldSpec(columnName, dataType);
      case TIME:
        return new TimeFieldSpec(columnName, dataType, timeUnit);
      default:
        throw new RuntimeException("Unsupported field type: " + fieldType);
    }
  }

  @Override
  public String toString() {
    final StringBuilder result = new StringBuilder();
    final String newLine = System.getProperty("line.separator");

    result.append(this.getClass().getName());
    result.append(" Object {");
    result.append(newLine);

    //determine fields declared in this class only (no fields of superclass)
    final Field[] fields = this.getClass().getDeclaredFields();

    //print field names paired with their values
    for (final Field field : fields) {
      result.append("  ");
      try {
        result.append(field.getName());
        result.append(": ");
        //requires access to private field:
        result.append(field.get(this));
      } catch (final IllegalAccessException ex) {
        if (LOGGER.isErrorEnabled()) {
          LOGGER.error("Unable to access field " + field, ex);
        }
        result.append("[ERROR]");
      }
      result.append(newLine);
    }
    result.append("}");

    return result.toString();
  }
}
